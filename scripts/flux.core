#!/system/bin/sh


# ==============================================================================
# Flux Core Management (flux.core)
# Description: Manages sing-box core process lifecycle (start/stop/restart)
#              Standalone executable with argument-based control
# ==============================================================================


# ------------------------------------------------------------------------------
# [ Environment Setup ]
# ------------------------------------------------------------------------------

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
. "$SCRIPT_DIR/flux.config"
. "$SCRIPT_DIR/flux.logger"

# Set log component name
export LOG_COMPONENT="Core"


# ==============================================================================
# [ Configuration Validation ]
# ==============================================================================

# Validate sing-box JSON configuration syntax
validate_singbox_config() {
    log_debug "Validating config..."
    
    local check_output check_result
    
    check_output=$("$SING_BOX_BIN" check -c "$CONFIG_FILE" -D "$RUN_DIR" 2>&1)
    check_result=$?
    
    if [ $check_result -ne 0 ]; then
        log_error "Config invalid"
        log_debug "Details: $check_output"
        return 1
    fi
    
    log_info "Config validated"
    return 0
}


# ==============================================================================
# [ Core Status Check ]
# ==============================================================================

# Check if core process is running and port is listening
is_core_running() {
    local pid_file="$PID_FILE"
    local pid
    
    pid=$(cat "$pid_file" 2>/dev/null) || return 1
    [ -z "$pid" ] && return 1
    echo "$pid" | grep -Eq '^[0-9]+$' || return 1
    kill -0 "$pid" 2>/dev/null || return 1
    netstat -tunlp 2>/dev/null | grep -q ":${PROXY_TCP_PORT}.*LISTEN"
}


# ==============================================================================
# [ Core Start ]
# ==============================================================================

# Start sing-box core process in background, write PID, wait for port
start_core() {
    log_debug "Starting sing-box..."
    
    # Ensure run directory exists
    [ ! -d "$RUN_DIR" ] && mkdir -p "$RUN_DIR"
    
    # Set ulimit for better connection handling
    ulimit -SHn 1000000 2>/dev/null
    
    # Launch sing-box with busybox setuidgid (box4magisk pattern)
    # Fall back to direct execution if busybox not available
    if command -v busybox >/dev/null 2>&1; then
        nohup busybox setuidgid "${CORE_USER}:${CORE_GROUP}" \
            "$SING_BOX_BIN" run \
            -c "$CONFIG_FILE" \
            -D "$RUN_DIR" \
            >/dev/null 2>>"$LOG_FILE" &
    else
        nohup "$SING_BOX_BIN" run \
            -c "$CONFIG_FILE" \
            -D "$RUN_DIR" \
            >/dev/null 2>>"$LOG_FILE" &
    fi
    
    local pid=$!
    echo -n "$pid" > "$PID_FILE"
    
    # Wait for port to be listening (with timeout)
    local start_wait_count=0
    while [ $start_wait_count -lt "$CORE_TIMEOUT" ]; do
        
        if is_core_running; then
            log_info "Core started (PID: $pid)"
            return 0
        fi
        
        sleep 0.5
        start_wait_count=$((start_wait_count + 1))
    done
    
    log_error "Core start failed (timeout), check $LOG_FILE"
    stop_core
    return 1
}


# ==============================================================================
# [ Core Stop ]
# ==============================================================================

# Stop sing-box core process gracefully (SIGTERM -> SIGKILL)
stop_core() {
    if [ -s "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE")
        
        if kill -0 "$pid" 2>/dev/null; then
            log_debug "Stopping PID $pid"
            kill "$pid" 2>/dev/null
            
            # Wait for graceful shutdown
            local stop_wait_count=0
            while kill -0 "$pid" 2>/dev/null && [ $stop_wait_count -lt "$CORE_TIMEOUT" ]; do
                sleep 0.5
                stop_wait_count=$((stop_wait_count + 1))
            done
            
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                log_debug "Force killing $pid"
                kill -9 "$pid" 2>/dev/null
                sleep 0.5
            fi
        fi
    else
        # Fallback: kill by pattern if no PID file
        pkill -9 -f "sing-box.*run.*$CONFIG_FILE" 2>/dev/null
    fi
    
    rm -f "$PID_FILE" 2>/dev/null
    log_info "Core stopped"
}


# ==============================================================================
# [ Core Restart ]
# ==============================================================================

# Restart core (stop then start)
restart_core() {
    log_info "Restarting core..."
    stop_core
    sleep 1
    validate_singbox_config && start_core
}


# ==============================================================================
# [ Main Entry Point ]
# ==============================================================================

main() {
    load_flux_config
    
    local action="${1:-}"
    
    case "$action" in
        start)
            is_core_running && { log_info "Core already running"; exit 0; }
            validate_singbox_config || exit 1
            start_core || exit 1
            ;;
        stop)
            stop_core || exit 1
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

main "$@"
